/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "StoreDB_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace storedb {


Key::~Key() throw() {
}


void Key::__set_id(const int64_t val) {
  this->id = val;
}

void Key::__set_command(const std::string& val) {
  this->command = val;
}

void Key::__set_email(const std::string& val) {
  this->email = val;
__isset.email = true;
}

const char* Key::ascii_fingerprint = "0C4016F101C6C444DB4E691757431FAD";
const uint8_t Key::binary_fingerprint[16] = {0x0C,0x40,0x16,0xF1,0x01,0xC6,0xC4,0x44,0xDB,0x4E,0x69,0x17,0x57,0x43,0x1F,0xAD};

uint32_t Key::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_command = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->command);
          isset_command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_command)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Key::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Key");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->command);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.email) {
    xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->email);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Key &a, Key &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.command, b.command);
  swap(a.email, b.email);
  swap(a.__isset, b.__isset);
}

Key::Key(const Key& other0) {
  id = other0.id;
  command = other0.command;
  email = other0.email;
  __isset = other0.__isset;
}
Key& Key::operator=(const Key& other1) {
  id = other1.id;
  command = other1.command;
  email = other1.email;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Key& obj) {
  using apache::thrift::to_string;
  out << "Key(";
  out << "id=" << to_string(obj.id);
  out << ", " << "command=" << to_string(obj.command);
  out << ", " << "email="; (obj.__isset.email ? (out << to_string(obj.email)) : (out << "<null>"));
  out << ")";
  return out;
}


Value::~Value() throw() {
}


void Value::__set_command(const std::string& val) {
  this->command = val;
}

void Value::__set_options(const std::string& val) {
  this->options = val;
}

void Value::__set_description(const std::string& val) {
  this->description = val;
}

void Value::__set_upVotes(const int64_t val) {
  this->upVotes = val;
}

void Value::__set_downVotes(const int64_t val) {
  this->downVotes = val;
}

const char* Value::ascii_fingerprint = "E2396C406CD75CE894E195C727905C26";
const uint8_t Value::binary_fingerprint[16] = {0xE2,0x39,0x6C,0x40,0x6C,0xD7,0x5C,0xE8,0x94,0xE1,0x95,0xC7,0x27,0x90,0x5C,0x26};

uint32_t Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_command = false;
  bool isset_options = false;
  bool isset_description = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->command);
          isset_command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->options);
          isset_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->description);
          isset_description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->upVotes);
          this->__isset.upVotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->downVotes);
          this->__isset.downVotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_command)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_description)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Value");

  xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->command);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->options);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upVotes", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->upVotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downVotes", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->downVotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Value &a, Value &b) {
  using ::std::swap;
  swap(a.command, b.command);
  swap(a.options, b.options);
  swap(a.description, b.description);
  swap(a.upVotes, b.upVotes);
  swap(a.downVotes, b.downVotes);
  swap(a.__isset, b.__isset);
}

Value::Value(const Value& other2) {
  command = other2.command;
  options = other2.options;
  description = other2.description;
  upVotes = other2.upVotes;
  downVotes = other2.downVotes;
  __isset = other2.__isset;
}
Value& Value::operator=(const Value& other3) {
  command = other3.command;
  options = other3.options;
  description = other3.description;
  upVotes = other3.upVotes;
  downVotes = other3.downVotes;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Value& obj) {
  using apache::thrift::to_string;
  out << "Value(";
  out << "command=" << to_string(obj.command);
  out << ", " << "options=" << to_string(obj.options);
  out << ", " << "description=" << to_string(obj.description);
  out << ", " << "upVotes=" << to_string(obj.upVotes);
  out << ", " << "downVotes=" << to_string(obj.downVotes);
  out << ")";
  return out;
}


Response::~Response() throw() {
}


void Response::__set_status(const bool val) {
  this->status = val;
}

void Response::__set_time(const double val) {
  this->time = val;
__isset.time = true;
}

void Response::__set_data(const std::string& val) {
  this->data = val;
__isset.data = true;
}

const char* Response::ascii_fingerprint = "2B9F0148AA280E12E64262FA5EF8CF2B";
const uint8_t Response::binary_fingerprint[16] = {0x2B,0x9F,0x01,0x48,0xAA,0x28,0x0E,0x12,0xE6,0x42,0x62,0xFA,0x5E,0xF8,0xCF,0x2B};

uint32_t Response::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Response");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->data);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Response &a, Response &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.time, b.time);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

Response::Response(const Response& other4) {
  status = other4.status;
  time = other4.time;
  data = other4.data;
  __isset = other4.__isset;
}
Response& Response::operator=(const Response& other5) {
  status = other5.status;
  time = other5.time;
  data = other5.data;
  __isset = other5.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Response& obj) {
  using apache::thrift::to_string;
  out << "Response(";
  out << "status=" << to_string(obj.status);
  out << ", " << "time="; (obj.__isset.time ? (out << to_string(obj.time)) : (out << "<null>"));
  out << ", " << "data="; (obj.__isset.data ? (out << to_string(obj.data)) : (out << "<null>"));
  out << ")";
  return out;
}


MultiResponse::~MultiResponse() throw() {
}


void MultiResponse::__set_status(const bool val) {
  this->status = val;
}

void MultiResponse::__set_time(const double val) {
  this->time = val;
__isset.time = true;
}

void MultiResponse::__set_data(const std::vector<std::string> & val) {
  this->data = val;
__isset.data = true;
}

const char* MultiResponse::ascii_fingerprint = "6F3B439354C74F26BFA95443F818BC43";
const uint8_t MultiResponse::binary_fingerprint[16] = {0x6F,0x3B,0x43,0x93,0x54,0xC7,0x4F,0x26,0xBF,0xA9,0x54,0x43,0xF8,0x18,0xBC,0x43};

uint32_t MultiResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->data.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readBinary(this->data[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MultiResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("MultiResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data.size()));
      std::vector<std::string> ::const_iterator _iter11;
      for (_iter11 = this->data.begin(); _iter11 != this->data.end(); ++_iter11)
      {
        xfer += oprot->writeBinary((*_iter11));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(MultiResponse &a, MultiResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.time, b.time);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

MultiResponse::MultiResponse(const MultiResponse& other12) {
  status = other12.status;
  time = other12.time;
  data = other12.data;
  __isset = other12.__isset;
}
MultiResponse& MultiResponse::operator=(const MultiResponse& other13) {
  status = other13.status;
  time = other13.time;
  data = other13.data;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const MultiResponse& obj) {
  using apache::thrift::to_string;
  out << "MultiResponse(";
  out << "status=" << to_string(obj.status);
  out << ", " << "time="; (obj.__isset.time ? (out << to_string(obj.time)) : (out << "<null>"));
  out << ", " << "data="; (obj.__isset.data ? (out << to_string(obj.data)) : (out << "<null>"));
  out << ")";
  return out;
}

} // namespace
